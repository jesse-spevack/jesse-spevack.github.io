---
layout: post
title: CompleteMe
categories:
- Turing
tags:
- Turing
status: publish
type: post
published: true
meta:
  _thumbnail_id: '38'
---
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<h1>Turing School of Software Design: Module 1, Week 2</h1>
<p>Week two of my <a href="https://www.turing.io/">Turing School</a> Module 1 experience is in the books and I am feeling great. This week we finished a project called <a target="_blank" href="https://github.com/turingschool/curriculum/blob/master/source/projects/complete_me.markdown">CompleteMe</a> and had classes covering topics ranging from Agile Development to Test Driven Design to Ruby's Object Model. Just like my <a target="_blank" href="http://www.jessespevack.com/systems-leadership/2016/7/2/75u8n0im73hd27a4yclc98qzl6hivu">previous post,</a> I want to give readers additional information from a student's perspective about Turing specifically and software bootcamps more generally. I also want to reflect on my own biggest takeaways from the week.</p>
<p>There were three big stand out understandings that came from class time this week for me. First, founder <a href="https://twitter.com/j3">Jeff Casimir</a>, shared one of his <a href="https://twitter.com/j3/status/751112558245842948">favorite lessons</a> - Ruby's Object Model, which I'll discuss below. Second, we looked at Test Driven Development (TDD), which is a methodology that involves writing tests for code before writing code. Third, we talked about Agile Development, which is a big deal in the software development world. Adherents take a cyclic approach to building software that involves rapid iteration and getting feedback from clients early and often. Agile Development on the micro scale is Test Driven Development in a lot of ways. On the macro scale Agile is how Turing is attempting to grow and achieve its <a href="https://www.turing.io/turing-difference">mission</a>. </p>
<h3>Test Driven Development</h3>
<p>TDD separates design and implementation in a way that theoretically prioritizes the former. A TDD practitioner asks, 'before I build this thing, what with this thing's form and function be and how will I know that I have been successful when it is built?' It's remarkably similar to what the education world calls backwards planning. When a teacher engages in backwards planning, they write the assessment students will have to complete at the end of a course of study before creating the course. In both TDD and backwards planning, design decisions are made up front so that implementation does not incentivize the creation of an easy to build but poorly designed course or product. This is the same reason architects and general contractors are typically two separate people. General contractors have an incentive to build things as inexpensively as possible, just like coders have an incentive to get code to work as quickly as possible. Architects are incentivized to design buildings that will bring utility to their clients. TDD practitioners take on the architect role thereby prioritizing functionality before engaging with questions of implementation. 'It should do this thing' should not yield to 'How do I make it do that thing?'</p>
<p>I found it particularly noteworthy that one of my classmates, a former student of astrophysics, took to TDD so religiously (I overheard him say that his test file was 400 lines, compared to the actual project file, which was probably fewer than 100 lines of code). TDD is basically the scientific method applied to programming. We ask questions, make observations and then refine the questions we ask based on those observations. I love science.</p>
<h3>Ruby's Object Model</h3>







 

  
  
    <div class="
          image-block-outer-wrapper
          layout-caption-below
          design-layout-inline
          
          
          
        " data-test="image-block-inline-outer-wrapper">

      

      
        <figure class="
              sqs-block-image-figure
              intrinsic
            " style="max-width:2048px;">
          
        
        

        
          
            
          <div style="padding-bottom:75%;" class="
                image-block-wrapper
                
          
        
                has-aspect-ratio
              " data-animation-role="image" data-animation-override>
            <noscript><img src="https://images.squarespace-cdn.com/content/v1/54ff9145e4b0d42b6a3b0734/1468073889868-QH2TFHB391OGIXNEPBHW/ke17ZwdGBToddI8pDm48kBZw6jF4_OvU-ddo_vwqGhp7gQa3H78H3Y0txjaiv_0fEtJToLhilMNuFwmcUDHJYRQNEivkRK0W_9ZDv6X_5baLYXVbONl_hZyFpVyn4qZhOqpeNLcJ80NK65_fV7S1USeK5UFU1jdTj27aAPwc4yDucTPmg3BJKC-9qj_02POpj3puZN32Aa4H3cmpC1xZMQ/image-asset.jpeg" alt="Above is Turing Founder,&amp;nbsp;Jeff Casimir's whiteboard notes from his lesson on Ruby's Object Model. My notebook's version is pictured at the top of this post."></noscript>
<img class="thumb-image" src="https://images.squarespace-cdn.com/content/v1/54ff9145e4b0d42b6a3b0734/1468073889868-QH2TFHB391OGIXNEPBHW/ke17ZwdGBToddI8pDm48kBZw6jF4_OvU-ddo_vwqGhp7gQa3H78H3Y0txjaiv_0fEtJToLhilMNuFwmcUDHJYRQNEivkRK0W_9ZDv6X_5baLYXVbONl_hZyFpVyn4qZhOqpeNLcJ80NK65_fV7S1USeK5UFU1jdTj27aAPwc4yDucTPmg3BJKC-9qj_02POpj3puZN32Aa4H3cmpC1xZMQ/image-asset.jpeg" data-image="https://images.squarespace-cdn.com/content/v1/54ff9145e4b0d42b6a3b0734/1468073889868-QH2TFHB391OGIXNEPBHW/ke17ZwdGBToddI8pDm48kBZw6jF4_OvU-ddo_vwqGhp7gQa3H78H3Y0txjaiv_0fEtJToLhilMNuFwmcUDHJYRQNEivkRK0W_9ZDv6X_5baLYXVbONl_hZyFpVyn4qZhOqpeNLcJ80NK65_fV7S1USeK5UFU1jdTj27aAPwc4yDucTPmg3BJKC-9qj_02POpj3puZN32Aa4H3cmpC1xZMQ/image-asset.jpeg" data-image-dimensions="2048x1536" data-image-focal-point="0.5,0.5" alt="Above is Turing Founder,&amp;nbsp;Jeff Casimir's whiteboard notes from his lesson on Ruby's Object Model. My notebook's version is pictured at the top of this post." data-load="false" data-image-id="578107a1b8a79b369b2fac05" data-type="image">
          </div>
        
          
        

        
          
          <figcaption class="image-caption-wrapper">
            <div class="image-caption"><p>Above is Turing Founder, Jeff Casimir's whiteboard notes from his lesson on Ruby's Object Model. My notebook's version is pictured at the top of this post.</p></div>
          </figcaption>
        
      
        </figure>
      

    </div>
  



<p>Through a combination of lecture and code along we walked down Ruby's object hierarchy with a hypothetical class, Ice Cream. The idea as I currently understand it, is that <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">Object Oriented Programming</a> in Ruby represents ideas with nouns, verbs, and adjectives - just like a regular spoken language. In programs I create with Ruby, I am able to define nouns, like in our classroom example of an object class called 'Ice Cream.' The Class Ice Cream is a template or cookie cutter that explains what things Ice Cream can do (Ice Cream's verbs, or in Ruby speak, methods) and what attributes Ice Cream possesses. For example, Ice Cream can melt. I can instantiate an instance of Ice Cream, called ic1, which takes on all the defined abilities and characteristics of my Ice Cream Class.</p>
<pre style="color:#000000;background:#ffffff;"><span style="color:#800000; font-weight:bold; ">class</span> IceCream
  <span style="color:#800000; font-weight:bold; ">def</span> melt
    <span style="color:#0000e6; ">"I am melting, better eat faster."</span><span style="color:#808030; "></span>
  <span style="color:#800000; font-weight:bold; ">end</span>
<span style="color:#800000; font-weight:bold; ">end</span>

ic1 <span style="color:#808030; ">=</span> IceCream<span style="color:#808030; ">.</span><span style="color:#800000; font-weight:bold; ">new</span>

ic1<span style="color:#808030; ">.</span>melt

<span style="color:#808030; ">=</span>&gt; <span style="color:#0000e6; ">"I am melting, better eat faster."</span><span style="color:#808030; "></span>
</pre>
<p>Where things in Ruby's Object Model get especially heady is that my ic1 instance inherits characteristics from other objects that sit above my IceCream class. At the top of the object hierarchy sits a Class poetically named Object, whose methods are available to my ic1 instance of IceCream (I'm told this is a case of information on a need to know basis and right now this is all I need to know). In Ruby the Class Object has a .class method which returns the object's class name. Since ic1 is an instance of an IceCream class that inherits methods from the Object class, ic1 does not exist in a permanent state of existential uncertainty. Instead, we can simply ask ic1 what type of object it is by calling the .class method and it will tell us that it is in fact IceCream.</p>
<pre style="color:#000000;background:#ffffff;">ic1<span style="color:#808030; ">.</span><span style="color:#800000; font-weight:bold; ">class</span>

<span style="color:#808030; ">=</span>&gt; IceCream
</pre>
<h3>Project: CompleteMe</h3>
<p>Our second project of Module 1, called CompleteMe, was a rudimentary autocomplete program that first loads in a dictionary of words and then can take in a prefix and return words from the dictionary that begin with the prefix. The project gets a little spicier with the notion of weighted suggestions whereby the program needs to also store the user's preferences regarding a given prefix so that next time that prefix is given, the user's past selected words are prioritized over other words. The full spec can be found <a href="https://github.com/turingschool/curriculum/blob/master/source/projects/complete_me.markdown">here</a>.</p>
<p>My key takeaways from the project were starting to wrap my mind (this is literal in this case) around the idea of recursion, how different variable scopes can cause huge headaches, and how TDD can really improve code design.</p>
<p>I got great feedback about my work from Turing Instructor, <a href="https://twitter.com/mikedao">Michael Dao</a>, who thought my code in general was well tested. Mike made several recommendations including:</p>
<ol>
<li>Test for more edge cases. For example, instead of testing to see if my code could suggest the word "pizza" from the prefix "piz" in a one word dictionary, add additional words like "egg" and "pi" to make sure the suggest method is really doing what it needs to do. In this case, "pi" is an edge case because it would be easy to mistakenly return "pi" from a "piz" prefix and that is incorrect behavior we would want to catch through testing.</li>
<li>Employ predicate methods with human readable names. Predicate methods in Ruby are methods that return true or false. For example, in my original code I was using multi-clause conditional statements to figure out it I was at the end of a word suggested by a prefix. Instead, my refactored code uses predicate methods that encapsulate the multi-clause conditionals into a more human readable condition (see below). </li>
<li>Organize the overall architecture of the code to include three classes: Nodes, Tries, and CompleteMes. In my case I turned in code with Nodes and a CompleteMe, but the big idea is to think about what these actual objects should be able to do. So a CompleteMe can suggest words, select words, and order words by weight, but a Trie can insert words, delete words (well my trie can't). Splitting that functionality into two separate classes makes the code more organized.</li>
</ol>
<pre style="color:#000000;background:#ffffff;"><span style="color:#696969; ">#Predicate Method Example</span>

<span style="color:#800000; font-weight:bold; ">if</span> a &amp;&amp; b &amp;&amp; c

<span style="color:#696969; ">#becomes</span>

<span style="color:#800000; font-weight:bold; ">def</span> my_conditions_are_true?(a, b, c)
  a &amp;&amp; b &amp;&amp; c
<span style="color:#800000; font-weight:bold; ">end</span>

<span style="color:#800000; font-weight:bold; ">if</span> my_conditions_are_true?<span style="color:#808030; ">(</span>a<span style="color:#808030; ">,</span> b<span style="color:#808030; ">,</span> c<span style="color:#808030; ">)</span>
</pre>
<h3>GEtting technical</h3>







 

  
  
    <div class="
          image-block-outer-wrapper
          layout-caption-below
          design-layout-inline
          
          
          
        " data-test="image-block-inline-outer-wrapper">

      

      
        <figure class="
              sqs-block-image-figure
              intrinsic
            " style="max-width:183px;">
          
        
        

        
          
            
          <div style="padding-bottom:345.9016418457031%;" class="
                image-block-wrapper
                
          
        
                has-aspect-ratio
              " data-animation-role="image" data-animation-override>
            <noscript><img src="https://images.squarespace-cdn.com/content/v1/54ff9145e4b0d42b6a3b0734/1468096993090-P4PWT1IX5KSQ0FFGCNNV/ke17ZwdGBToddI8pDm48kIGNNKiDZtAeV-UXjxq67kdZw-zPPgdn4jUwVcJE1ZvWhcwhEtWJXoshNdA9f1qD7UPPfIJFSF9MDeSHXxnsR9qdAXQZ1nuD_ixoTkURptvdPb3PI3vLN1W730j4k5bvDw/image-asset.png" alt=""></noscript>
<img class="thumb-image" src="https://images.squarespace-cdn.com/content/v1/54ff9145e4b0d42b6a3b0734/1468096993090-P4PWT1IX5KSQ0FFGCNNV/ke17ZwdGBToddI8pDm48kIGNNKiDZtAeV-UXjxq67kdZw-zPPgdn4jUwVcJE1ZvWhcwhEtWJXoshNdA9f1qD7UPPfIJFSF9MDeSHXxnsR9qdAXQZ1nuD_ixoTkURptvdPb3PI3vLN1W730j4k5bvDw/image-asset.png" data-image="https://images.squarespace-cdn.com/content/v1/54ff9145e4b0d42b6a3b0734/1468096993090-P4PWT1IX5KSQ0FFGCNNV/ke17ZwdGBToddI8pDm48kIGNNKiDZtAeV-UXjxq67kdZw-zPPgdn4jUwVcJE1ZvWhcwhEtWJXoshNdA9f1qD7UPPfIJFSF9MDeSHXxnsR9qdAXQZ1nuD_ixoTkURptvdPb3PI3vLN1W730j4k5bvDw/image-asset.png" data-image-dimensions="183x633" data-image-focal-point="0.5,0.5" alt="" data-load="false" data-image-id="578161d2f5e2316f63d8bdd8" data-type="image">
          </div>
        
          
        

        
      
        </figure>
      

    </div>
  



<p>The first challenge of project CompleteMe is to figure out how to store a dictionary. In keeping with Turing's preference for just in time instruction and just too late instruction, our instructor <a href="https://twitter.com/mikedao">Michael Dao</a> delivered a lesson on the Trie data structure. In the world of project-based learning, which I know intimately from my days as an assistant principal at the <a href="http://www.nycischool.org/">NYC iSchool</a>, the idea of just in time instruction is to provide learning at the moment closest to when it will be applied by the student.</p>
<p>A <a href="https://en.wikipedia.org/wiki/Trie">Trie</a> is a data structure that organizes information on a series of branching nodes such that each node is keyed to its values. Meaning is inferred by traversing the tree. For example, a Trie that stores the words "pi", "pizza", and "pizzeria" can do so by using nodes to represent the letters "p", "i", "z", "z", "a", "e", "r", "i", and "a". That is a savings of 6 letters - "p" and "i" twice for "pizza" and "pizzeria", and "z", "z" once for "pizzeria"! By traversing down the tree, the structure builds words from individual nodes. To access the word "pizza" we move down the "p", "i", nodes shared by all three words in our dictionary, and the "z" shared by "pizza" and "pizzeria" and then down the "a" branch unique to "pizza". Tries are similar to <a href="https://en.wikipedia.org/wiki/Linked_list">linked lists</a> and <a href="https://en.wikipedia.org/wiki/Binary_tree">binary trees</a>, but dissimilar because each node in a Trie can have many child nodes.  </p>
<p>To build a Trie and to traverse it in order to make meaning from the arrangement of nodes requires a little trick called <a href="https://en.wikipedia.org/wiki/Recursion">recursion</a>. Recursion in Computer Science is when a function calls itself on its own results. I think about it like folding a piece of paper where folding is the verb (or method in Ruby) and the paper is the input and the output that the method fold is called on. In the physical world paper can only be folded so many times, but in the virtual world of code a method can be called on its own results indefinitely.</p>
<pre style="color:#000000;background:#ffffff;"><span style="color:#800000; font-weight:bold; ">def</span> fold(paper)
  paper <span style="color:#808030; ">=</span> <span style="color:#0000e6; ">"paper is now folded in half"</span>
  fold<span style="color:#808030; ">(</span>paper<span style="color:#808030; ">)</span>
<span style="color:#800000; font-weight:bold; ">end</span>
</pre>
<h3>The Code</h3>
<p>I want to share what I think are the most interesting parts of the code here. My entire project can be found on my <a target="_blank" href="https://github.com/PlanetEfficacy/CompleteMe">GitHub page</a>. </p>
<pre style="color:#000000;background:#ffffff;"><span style="color:#800000; font-weight:bold; ">class</span> Node

  attr_accessor :<span style="color:#005fd2; ">flag</span><span style="color:#808030; ">,</span>
                :<span style="color:#005fd2; ">children</span><span style="color:#808030; ">,</span>
                :<span style="color:#005fd2; ">weight</span>

  <span style="color:#800000; font-weight:bold; ">def</span> initialize
    @flag <span style="color:#808030; ">=</span> <span style="color:#800000; font-weight:bold; ">false</span>
    @children <span style="color:#808030; ">=</span> <span style="color:#800080; ">{</span><span style="color:#800080; ">}</span>
    @weight <span style="color:#808030; ">=</span> <span style="color:#800080; ">{</span><span style="color:#800080; ">}</span>
  <span style="color:#800000; font-weight:bold; ">end</span>

  <span style="color:#800000; font-weight:bold; ">def</span> has_children?
    !@children<span style="color:#808030; ">.</span><span style="color:#400000; ">empty?</span>
  <span style="color:#800000; font-weight:bold; ">end</span>

  <span style="color:#800000; font-weight:bold; ">def</span> does_not_have_children?
    @children<span style="color:#808030; ">.</span><span style="color:#400000; ">empty?</span>
  <span style="color:#800000; font-weight:bold; ">end</span>

<span style="color:#800000; font-weight:bold; ">end</span>
</pre>
<p>In the above code snippet I define the Node Class. A node begins with three attributes. First, a node has a flag to signify if it is the final node of a word. By default a node's flag is is initialized to false. A node also has a hash of child nodes, which, of course, is empty if the node has no children. Finally, a node has weight, which is a hash of prefix keys and weight values to signify the preference a given word should be awarded. I think about it as if certain branches of the Trie are heavier than others. In my imagining of a node, they can also tell if they have children or not with <em>has_children? </em>and <em>does_not_have_children? </em>methods.</p>
<pre style="color:#000000;background:#ffffff;"><span style="color:#800000; font-weight:bold; ">def</span> insert(word)
  node <span style="color:#808030; ">=</span> @root
  word<span style="color:#808030; ">.</span><span style="color:#400000; ">each_char</span><span style="color:#808030; ">.</span><span style="color:#400000; ">map</span><span style="color:#800000; font-weight:bold; "> do</span> |letter|
<span style="color:#800000; font-weight:bold; ">    if</span> !node<span style="color:#808030; ">.</span>children<span style="color:#808030; ">.</span><span style="color:#400000; ">has_key?</span><span style="color:#808030; ">(</span>letter<span style="color:#808030; ">)</span>
      node<span style="color:#808030; ">.</span>children<span style="color:#808030; ">[</span>letter<span style="color:#808030; ">]</span> <span style="color:#808030; ">=</span> Node<span style="color:#808030; ">.</span><span style="color:#800000; font-weight:bold; ">new</span>
    <span style="color:#800000; font-weight:bold; ">end</span>
    node <span style="color:#808030; ">=</span> node<span style="color:#808030; ">.</span>children<span style="color:#808030; ">[</span>letter<span style="color:#808030; ">]</span>
  <span style="color:#800000; font-weight:bold; ">end</span>
  node<span style="color:#808030; ">.</span>flag <span style="color:#808030; ">=</span> <span style="color:#800000; font-weight:bold; ">true</span>
  <span style="color:#800000; font-weight:bold; ">return</span>
<span style="color:#800000; font-weight:bold; ">end</span>
</pre>
<p>The insert method above is part of the Trie Class. A Trie initially consists of one root node, which has no key because it actually does not represent a letter. It only represents the start of the entire trie. Every time the Trie is told to insert a word, the Trie traverses down itself from its root and checks for each letter in the given word. If the letter is found to exist as a child node, the traversal moves down a level in the Trie. If not, a new node is instantiated and keyed to the given letter. When the final letter's node is located or instantiated, the node's flag is set to true to signify the end of a newly inserted word.</p>
<pre style="color:#000000;background:#ffffff;"><span style="color:#800000; font-weight:bold; ">def</span> count(node=@root)
  word_count <span style="color:#808030; ">=</span> <span style="color:#008c00; ">0</span>
  word_count <span style="color:#808030; ">+</span><span style="color:#808030; ">=</span> <span style="color:#008c00; ">1</span> <span style="color:#800000; font-weight:bold; ">if</span> node<span style="color:#808030; ">.</span>flag
<span style="color:#800000; font-weight:bold; ">  if</span> node<span style="color:#808030; ">.</span>has_children?
    node<span style="color:#808030; ">.</span>children<span style="color:#808030; ">.</span><span style="color:#400000; ">keys</span><span style="color:#808030; ">.</span><span style="color:#800000; font-weight:bold; ">each</span><span style="color:#800000; font-weight:bold; "> do</span> |letter|
      child_node <span style="color:#808030; ">=</span> node<span style="color:#808030; ">.</span>children<span style="color:#808030; ">[</span>letter<span style="color:#808030; ">]</span>
      word_count <span style="color:#808030; ">+</span><span style="color:#808030; ">=</span> <span style="color:#400000; ">count</span><span style="color:#808030; ">(</span>child_node<span style="color:#808030; ">)</span>
    <span style="color:#800000; font-weight:bold; ">end</span>
  <span style="color:#800000; font-weight:bold; ">end</span>
  <span style="color:#800000; font-weight:bold; ">return</span> word_count
<span style="color:#800000; font-weight:bold; ">end</span>
</pre>
<p>Like the insert method, the count method is also part of the Trie Class. A Trie can count all of its words by finding all of the nodes with flags set to the boolean true value. The count function is one of a few places in this project where I had to employ recursion. Count takes a node as an input and will count all of the words that are built from the children of that input node. If no node is input, the Count method will take the root node of the Trie and begin its count from there. Everytime count finds a node with a flag set to true, it increments the <em>word_count</em> variable by one. Next, it checks to see if the node has children nodes. If there are no child nodes, the count method has reached the end of the trie and returns the <em>word_count</em> variable. However, if the node has children, the Count method iteratively calls itself on each child node.</p>
<p>This was by far the hardest part of the program to conceptualize for myself. In fact, one of my classmates helped me troubleshoot my count method after it had me stuck for several hours. Now that I've had to use that recursive technique in a few other places, it makes a lot more sense. For readers interested in learning recursion, the trick for me was just write multiple methods that are recursive. Eventually the concept became clear.</p>
<pre style="color:#000000;background:#ffffff;"><span style="color:#800000; font-weight:bold; ">def</span> suggest(prefix)
  suggestions <span style="color:#808030; ">=</span> <span style="color:#808030; ">[</span><span style="color:#808030; ">]</span>
  node <span style="color:#808030; ">=</span> @trie<span style="color:#808030; ">.</span>root
  prefix<span style="color:#808030; ">.</span><span style="color:#400000; ">each_char</span><span style="color:#800000; font-weight:bold; "> do</span> |letter|
    <span style="color:#800000; font-weight:bold; ">return</span> <span style="color:#800000; font-weight:bold; ">nil</span> <span style="color:#800000; font-weight:bold; ">if</span> !node<span style="color:#808030; ">.</span>children<span style="color:#808030; ">.</span><span style="color:#400000; ">has_key?</span><span style="color:#808030; ">(</span>letter<span style="color:#808030; ">)</span>
    node <span style="color:#808030; ">=</span> node<span style="color:#808030; ">.</span>children<span style="color:#808030; ">[</span>letter<span style="color:#808030; ">]</span>
  <span style="color:#800000; font-weight:bold; ">end</span>
  find_all_the_words<span style="color:#808030; ">(</span>node<span style="color:#808030; ">,</span> prefix<span style="color:#808030; ">,</span> suggestions<span style="color:#808030; ">)</span>
  suggestions <span style="color:#808030; ">=</span> order_suggestions_by_weight<span style="color:#808030; ">(</span>suggestions<span style="color:#808030; ">,</span> prefix<span style="color:#808030; ">)</span>
  <span style="color:#800000; font-weight:bold; ">return</span> suggestions
<span style="color:#800000; font-weight:bold; ">end</span>
</pre>
<p>The suggest method is part of the CompleteMe class. It takes in a prefix, like "piz". Next it looks at the root of the Trie to see if any of the children nodes are keyed to the first letter of the prefix, such as "p". If it finds an appropriately keyed child node, it moves down the trie <em>node = node.children[lettter]</em>. When the end of the prefix is found, the suggest method calls the <em>find_all_the_words</em> method on the node it traversed down to. Again, recursion is the magic that makes <em>finda_all_the_words</em> return an array of all the words that lie below the starting node. Lastly, the suggestions are organized by weight in the <em>order_suggestions_by_weight</em> method. What is interesting about this snippet of code is how I utilize the idea of scope to hold on to and update variables as I traverse down the Trie. Scope is basically the code's field of vision; the data it knows about and can access. Since I am still beginning my Ruby journey, I often mistakenly believe that my code does or does not have access to particular data. This was a section of my code where that shaky understanding really slowed my progress.</p>
<pre style="color:#000000;background:#ffffff;"><span style="color:#800000; font-weight:bold; ">def</span> find_all_the_words(node, prefix, suggestions)
  suggestions &lt;&lt; prefix <span style="color:#800000; font-weight:bold; ">if</span> node<span style="color:#808030; ">.</span>flag
<span style="color:#800000; font-weight:bold; ">  if</span> node<span style="color:#808030; ">.</span>has_children?
    node<span style="color:#808030; ">.</span>children<span style="color:#808030; ">.</span><span style="color:#400000; ">keys</span><span style="color:#808030; ">.</span><span style="color:#800000; font-weight:bold; ">each</span><span style="color:#800000; font-weight:bold; "> do</span> |letter|
      node_prefix <span style="color:#808030; ">=</span> prefix
      node_prefix <span style="color:#808030; ">+</span><span style="color:#808030; ">=</span> letter
      child_node <span style="color:#808030; ">=</span> node<span style="color:#808030; ">.</span>children<span style="color:#808030; ">[</span>letter<span style="color:#808030; ">]</span>
      find_all_the_words<span style="color:#808030; ">(</span>child_node<span style="color:#808030; ">,</span> node_prefix<span style="color:#808030; ">,</span> suggestions<span style="color:#808030; ">)</span>
    <span style="color:#800000; font-weight:bold; ">end</span>
  <span style="color:#800000; font-weight:bold; ">end</span>
  <span style="color:#800000; font-weight:bold; ">return</span> suggestions
<span style="color:#800000; font-weight:bold; ">end</span>
</pre>
<p>Notice how <em>find_all_the_words</em> creates a <em>node_prefix</em> and <em>child_node</em> variables. This is to help me keep track of these values as the method traversed down the Trie and avoid issues of scope conflict.</p>
<pre style="color:#000000;background:#ffffff;"><span style="color:#800000; font-weight:bold; ">def</span> test_it_can_find_weight
  c <span style="color:#808030; ">=</span> CompleteMe<span style="color:#808030; ">.</span><span style="color:#800000; font-weight:bold; ">new</span>
  t <span style="color:#808030; ">=</span> c<span style="color:#808030; ">.</span>trie
  words <span style="color:#808030; ">=</span> <span style="color:#808030; ">[</span><span style="color:#0000e6; ">"pi"</span><span style="color:#808030; ">,</span> <span style="color:#0000e6; ">"pize"</span><span style="color:#808030; ">,</span> <span style="color:#0000e6; ">"pizz"</span><span style="color:#808030; ">,</span> <span style="color:#0000e6; ">"pizza"</span><span style="color:#808030; ">,</span> <span style="color:#0000e6; ">"pizzeria"</span><span style="color:#808030; ">,</span> <span style="color:#0000e6; ">"pizzicato"</span><span style="color:#808030; ">]</span><span style="color:#808030; ">.</span><span style="color:#400000; ">join</span><span style="color:#808030; ">(</span><span style="color:#0000e6; ">"\n"</span><span style="color:#808030; ">)</span>
  c<span style="color:#808030; ">.</span>populate<span style="color:#808030; ">(</span>words<span style="color:#808030; ">)</span>
  expected1 <span style="color:#808030; ">=</span> <span style="color:#008c00; ">1</span>
  expected2 <span style="color:#808030; ">=</span> <span style="color:#008c00; ">2</span>
  expected3 <span style="color:#808030; ">=</span> <span style="color:#008c00; ">4</span>
  expected4 <span style="color:#808030; ">=</span> <span style="color:#008c00; ">1</span>

  c<span style="color:#808030; ">.</span><span style="color:#400000; ">select</span><span style="color:#808030; ">(</span><span style="color:#0000e6; ">"piz"</span><span style="color:#808030; ">,</span> <span style="color:#0000e6; ">"pizzeria"</span><span style="color:#808030; ">)</span>
  actual1 <span style="color:#808030; ">=</span> c<span style="color:#808030; ">.</span>find_weight<span style="color:#808030; ">(</span><span style="color:#0000e6; ">"piz"</span><span style="color:#808030; ">,</span> <span style="color:#0000e6; ">"pizzeria"</span><span style="color:#808030; ">)</span>
  c<span style="color:#808030; ">.</span><span style="color:#400000; ">select</span><span style="color:#808030; ">(</span><span style="color:#0000e6; ">"piz"</span><span style="color:#808030; ">,</span> <span style="color:#0000e6; ">"pizzeria"</span><span style="color:#808030; ">)</span>
  actual2 <span style="color:#808030; ">=</span> c<span style="color:#808030; ">.</span>find_weight<span style="color:#808030; ">(</span><span style="color:#0000e6; ">"piz"</span><span style="color:#808030; ">,</span> <span style="color:#0000e6; ">"pizzeria"</span><span style="color:#808030; ">)</span>
  c<span style="color:#808030; ">.</span><span style="color:#400000; ">select</span><span style="color:#808030; ">(</span><span style="color:#0000e6; ">"piz"</span><span style="color:#808030; ">,</span> <span style="color:#0000e6; ">"pizzeria"</span><span style="color:#808030; ">)</span>
  c<span style="color:#808030; ">.</span><span style="color:#400000; ">select</span><span style="color:#808030; ">(</span><span style="color:#0000e6; ">"piz"</span><span style="color:#808030; ">,</span> <span style="color:#0000e6; ">"pizzeria"</span><span style="color:#808030; ">)</span>
  c<span style="color:#808030; ">.</span><span style="color:#400000; ">select</span><span style="color:#808030; ">(</span><span style="color:#0000e6; ">"piz"</span><span style="color:#808030; ">,</span> <span style="color:#0000e6; ">"pizza"</span><span style="color:#808030; ">)</span>
  actual3 <span style="color:#808030; ">=</span> c<span style="color:#808030; ">.</span>find_weight<span style="color:#808030; ">(</span><span style="color:#0000e6; ">"piz"</span><span style="color:#808030; ">,</span> <span style="color:#0000e6; ">"pizzeria"</span><span style="color:#808030; ">)</span>
  actual4 <span style="color:#808030; ">=</span> c<span style="color:#808030; ">.</span>find_weight<span style="color:#808030; ">(</span><span style="color:#0000e6; ">"piz"</span><span style="color:#808030; ">,</span> <span style="color:#0000e6; ">"pizza"</span><span style="color:#808030; ">)</span>

  assert_equal expected1<span style="color:#808030; ">,</span> actual1
  assert_equal expected2<span style="color:#808030; ">,</span> actual2
  assert_equal expected3<span style="color:#808030; ">,</span> actual3
  assert_equal expected4<span style="color:#808030; ">,</span> actual4
<span style="color:#800000; font-weight:bold; ">end</span>
</pre>
<p>This test method is really when TDD started to click. Like trying to learn any new technique, TDD initially significantly slowed my progress. However, by the time I started to consider how to weight certain words given particular prefixes I actually think TDD if not accelerated my work certainly improved the final product. I wrote the above code <em>prior</em> to writing the <em>find_weight</em> method. I played the part of the architect and imagined in my ideal world what the <em>find_weight</em> method should return. I gave no consideration to implementation or my poor future general contractor self. I imagined a method that would return an integer based on the number of times a given word was selected off of a particular prefix. I designed cases to test whether or not my as-yet-unwritten <em>find_weight </em>method would return the weights I expected given a particular set of selections. For example, "pizzeria" one time from the prefix "piz", I would expect <em>find_weight</em> to return a weight of 1 on the "piz" prefix "pizzeria" suggestion pair. Once my tests were designed my implementation had direction. More importantly, my implementation had a vision of a future state where a <em>find_weight </em>method could return a simple integer corresponding to a prefix-suggestion pair's weight.</p>
<h3>Conclusions</h3>
<p>There was definitely a point on Wednesday when I expected that I would have to pull an all-nighter on Thursday to meet the Friday deadline. Thankfully that was not the case, but the feeling of self-doubt and dejection was very real and made the completion of the project that much sweeter. At Turing though, there is little time to celebrate as my next project has already begun.</p>
</body></html>
